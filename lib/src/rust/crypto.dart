// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'error.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `derive_key`, `generate_salt`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Encrypt text using AES-256-GCM
Future<String> encryptTextImpl({required String text, required String password}) =>
    RustLib.instance.api.crateCryptoEncryptTextImpl(text: text, password: password);

/// Decrypt text using AES-256-GCM
Future<String> decryptTextImpl({required String encryptedData, required String password}) =>
    RustLib.instance.api.crateCryptoDecryptTextImpl(encryptedData: encryptedData, password: password);

/// Encrypt a file using AES-256-GCM
Future<void> encryptFileImpl({required String inputPath, required String outputPath, required String password}) =>
    RustLib.instance.api.crateCryptoEncryptFileImpl(inputPath: inputPath, outputPath: outputPath, password: password);

/// Decrypt a file using AES-256-GCM
Future<void> decryptFileImpl({required String inputPath, required String outputPath, required String password}) =>
    RustLib.instance.api.crateCryptoDecryptFileImpl(inputPath: inputPath, outputPath: outputPath, password: password);

/// Hash text using the specified algorithm
Future<String> hashTextImpl({required String text, required String algorithm}) =>
    RustLib.instance.api.crateCryptoHashTextImpl(text: text, algorithm: algorithm);

/// Generate a cryptographically secure random key
Future<String> generateSecureKeyImpl({required int length}) =>
    RustLib.instance.api.crateCryptoGenerateSecureKeyImpl(length: length);

/// Generate RSA key pair
Future<RsaKeyPair> generateRsaKeyPairImpl({required int keySize}) =>
    RustLib.instance.api.crateCryptoGenerateRsaKeyPairImpl(keySize: keySize);

/// Encrypt text using RSA public key
Future<String> rsaEncryptImpl({required String text, required String publicKeyPem}) =>
    RustLib.instance.api.crateCryptoRsaEncryptImpl(text: text, publicKeyPem: publicKeyPem);

/// Decrypt text using RSA private key
Future<String> rsaDecryptImpl({required String encryptedData, required String privateKeyPem}) =>
    RustLib.instance.api.crateCryptoRsaDecryptImpl(encryptedData: encryptedData, privateKeyPem: privateKeyPem);

/// Sign text using RSA private key
Future<String> rsaSignImpl({required String text, required String privateKeyPem}) =>
    RustLib.instance.api.crateCryptoRsaSignImpl(text: text, privateKeyPem: privateKeyPem);

/// Verify RSA signature
Future<bool> rsaVerifyImpl({required String text, required String signature, required String publicKeyPem}) =>
    RustLib.instance.api.crateCryptoRsaVerifyImpl(text: text, signature: signature, publicKeyPem: publicKeyPem);

/// RSA key pair structure
class RsaKeyPair {
  final String privateKeyPem;
  final String publicKeyPem;

  const RsaKeyPair({
    required this.privateKeyPem,
    required this.publicKeyPem,
  });

  @override
  int get hashCode => privateKeyPem.hashCode ^ publicKeyPem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RsaKeyPair &&
          runtimeType == other.runtimeType &&
          privateKeyPem == other.privateKeyPem &&
          publicKeyPem == other.publicKeyPem;
}
