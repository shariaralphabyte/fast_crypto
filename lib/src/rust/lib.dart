// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'crypto.dart';
import 'error.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Encrypt text using AES-256-GCM with PBKDF2 key derivation
///
/// # Arguments
/// * `text` - The plaintext to encrypt
/// * `password` - The password to derive the encryption key from
///
/// # Returns
/// * `Result<String, CryptoError>` - Base64 encoded encrypted data or error
String encryptText({required String text, required String password}) =>
    RustLib.instance.api.crateEncryptText(text: text, password: password);

/// Decrypt text using AES-256-GCM with PBKDF2 key derivation
///
/// # Arguments
/// * `encrypted_data` - Base64 encoded encrypted data
/// * `password` - The password to derive the decryption key from
///
/// # Returns
/// * `Result<String, CryptoError>` - Decrypted plaintext or error
String decryptText({required String encryptedData, required String password}) =>
    RustLib.instance.api.crateDecryptText(encryptedData: encryptedData, password: password);

/// Encrypt a file using AES-256-GCM
///
/// # Arguments
/// * `input_path` - Path to the input file
/// * `output_path` - Path to save the encrypted file
/// * `password` - The password to derive the encryption key from
///
/// # Returns
/// * `Result<(), CryptoError>` - Success or error
Future<void> encryptFile({required String inputPath, required String outputPath, required String password}) =>
    RustLib.instance.api.crateEncryptFile(inputPath: inputPath, outputPath: outputPath, password: password);

/// Decrypt a file using AES-256-GCM
///
/// # Arguments
/// * `input_path` - Path to the encrypted file
/// * `output_path` - Path to save the decrypted file
/// * `password` - The password to derive the decryption key from
///
/// # Returns
/// * `Result<(), CryptoError>` - Success or error
Future<void> decryptFile({required String inputPath, required String outputPath, required String password}) =>
    RustLib.instance.api.crateDecryptFile(inputPath: inputPath, outputPath: outputPath, password: password);

/// Hash text using the specified algorithm
///
/// # Arguments
/// * `text` - The text to hash
/// * `algorithm` - The hash algorithm ("sha256", "sha512")
///
/// # Returns
/// * `Result<String, CryptoError>` - Hex encoded hash or error
String hashText({required String text, required String algorithm}) =>
    RustLib.instance.api.crateHashText(text: text, algorithm: algorithm);

/// Generate a cryptographically secure random key
///
/// # Arguments
/// * `length` - The length of the key in bytes
///
/// # Returns
/// * `Result<String, CryptoError>` - Base64 encoded random key or error
String generateSecureKey({required int length}) => RustLib.instance.api.crateGenerateSecureKey(length: length);

/// Generate RSA key pair
///
/// # Arguments
/// * `key_size` - The size of the RSA key in bits (2048, 3072, 4096)
///
/// # Returns
/// * `Result<RsaKeyPair, CryptoError>` - RSA key pair or error
Future<RsaKeyPair> generateRsaKeyPair({required int keySize}) =>
    RustLib.instance.api.crateGenerateRsaKeyPair(keySize: keySize);

/// Encrypt text using RSA public key
///
/// # Arguments
/// * `text` - The plaintext to encrypt
/// * `public_key_pem` - The RSA public key in PEM format
///
/// # Returns
/// * `Result<String, CryptoError>` - Base64 encoded encrypted data or error
String rsaEncrypt({required String text, required String publicKeyPem}) =>
    RustLib.instance.api.crateRsaEncrypt(text: text, publicKeyPem: publicKeyPem);

/// Decrypt text using RSA private key
///
/// # Arguments
/// * `encrypted_data` - Base64 encoded encrypted data
/// * `private_key_pem` - The RSA private key in PEM format
///
/// # Returns
/// * `Result<String, CryptoError>` - Decrypted plaintext or error
String rsaDecrypt({required String encryptedData, required String privateKeyPem}) =>
    RustLib.instance.api.crateRsaDecrypt(encryptedData: encryptedData, privateKeyPem: privateKeyPem);

/// Sign text using RSA private key
///
/// # Arguments
/// * `text` - The text to sign
/// * `private_key_pem` - The RSA private key in PEM format
///
/// # Returns
/// * `Result<String, CryptoError>` - Base64 encoded signature or error
String rsaSign({required String text, required String privateKeyPem}) =>
    RustLib.instance.api.crateRsaSign(text: text, privateKeyPem: privateKeyPem);

/// Verify RSA signature
///
/// # Arguments
/// * `text` - The original text
/// * `signature` - Base64 encoded signature
/// * `public_key_pem` - The RSA public key in PEM format
///
/// # Returns
/// * `Result<bool, CryptoError>` - Verification result or error
bool rsaVerify({required String text, required String signature, required String publicKeyPem}) =>
    RustLib.instance.api.crateRsaVerify(text: text, signature: signature, publicKeyPem: publicKeyPem);
