// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CryptoError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CryptoErrorCopyWith<$Res> {
  factory $CryptoErrorCopyWith(CryptoError value, $Res Function(CryptoError) then) =
      _$CryptoErrorCopyWithImpl<$Res, CryptoError>;
}

/// @nodoc
class _$CryptoErrorCopyWithImpl<$Res, $Val extends CryptoError> implements $CryptoErrorCopyWith<$Res> {
  _$CryptoErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CryptoError_InvalidInputImplCopyWith<$Res> {
  factory _$$CryptoError_InvalidInputImplCopyWith(
          _$CryptoError_InvalidInputImpl value, $Res Function(_$CryptoError_InvalidInputImpl) then) =
      __$$CryptoError_InvalidInputImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_InvalidInputImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_InvalidInputImpl>
    implements _$$CryptoError_InvalidInputImplCopyWith<$Res> {
  __$$CryptoError_InvalidInputImplCopyWithImpl(
      _$CryptoError_InvalidInputImpl _value, $Res Function(_$CryptoError_InvalidInputImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_InvalidInputImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_InvalidInputImpl extends CryptoError_InvalidInput {
  const _$CryptoError_InvalidInputImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.invalidInput(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_InvalidInputImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_InvalidInputImplCopyWith<_$CryptoError_InvalidInputImpl> get copyWith =>
      __$$CryptoError_InvalidInputImplCopyWithImpl<_$CryptoError_InvalidInputImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return invalidInput(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return invalidInput?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (invalidInput != null) {
      return invalidInput(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return invalidInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return invalidInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (invalidInput != null) {
      return invalidInput(this);
    }
    return orElse();
  }
}

abstract class CryptoError_InvalidInput extends CryptoError {
  const factory CryptoError_InvalidInput({required final String message}) = _$CryptoError_InvalidInputImpl;
  const CryptoError_InvalidInput._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_InvalidInputImplCopyWith<_$CryptoError_InvalidInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_EncryptionFailedImplCopyWith<$Res> {
  factory _$$CryptoError_EncryptionFailedImplCopyWith(
          _$CryptoError_EncryptionFailedImpl value, $Res Function(_$CryptoError_EncryptionFailedImpl) then) =
      __$$CryptoError_EncryptionFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_EncryptionFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_EncryptionFailedImpl>
    implements _$$CryptoError_EncryptionFailedImplCopyWith<$Res> {
  __$$CryptoError_EncryptionFailedImplCopyWithImpl(
      _$CryptoError_EncryptionFailedImpl _value, $Res Function(_$CryptoError_EncryptionFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_EncryptionFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_EncryptionFailedImpl extends CryptoError_EncryptionFailed {
  const _$CryptoError_EncryptionFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.encryptionFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_EncryptionFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_EncryptionFailedImplCopyWith<_$CryptoError_EncryptionFailedImpl> get copyWith =>
      __$$CryptoError_EncryptionFailedImplCopyWithImpl<_$CryptoError_EncryptionFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return encryptionFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return encryptionFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (encryptionFailed != null) {
      return encryptionFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return encryptionFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return encryptionFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (encryptionFailed != null) {
      return encryptionFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_EncryptionFailed extends CryptoError {
  const factory CryptoError_EncryptionFailed({required final String message}) = _$CryptoError_EncryptionFailedImpl;
  const CryptoError_EncryptionFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_EncryptionFailedImplCopyWith<_$CryptoError_EncryptionFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_DecryptionFailedImplCopyWith<$Res> {
  factory _$$CryptoError_DecryptionFailedImplCopyWith(
          _$CryptoError_DecryptionFailedImpl value, $Res Function(_$CryptoError_DecryptionFailedImpl) then) =
      __$$CryptoError_DecryptionFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_DecryptionFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_DecryptionFailedImpl>
    implements _$$CryptoError_DecryptionFailedImplCopyWith<$Res> {
  __$$CryptoError_DecryptionFailedImplCopyWithImpl(
      _$CryptoError_DecryptionFailedImpl _value, $Res Function(_$CryptoError_DecryptionFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_DecryptionFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_DecryptionFailedImpl extends CryptoError_DecryptionFailed {
  const _$CryptoError_DecryptionFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.decryptionFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_DecryptionFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_DecryptionFailedImplCopyWith<_$CryptoError_DecryptionFailedImpl> get copyWith =>
      __$$CryptoError_DecryptionFailedImplCopyWithImpl<_$CryptoError_DecryptionFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return decryptionFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return decryptionFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (decryptionFailed != null) {
      return decryptionFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return decryptionFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return decryptionFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (decryptionFailed != null) {
      return decryptionFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_DecryptionFailed extends CryptoError {
  const factory CryptoError_DecryptionFailed({required final String message}) = _$CryptoError_DecryptionFailedImpl;
  const CryptoError_DecryptionFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_DecryptionFailedImplCopyWith<_$CryptoError_DecryptionFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_KeyGenerationFailedImplCopyWith<$Res> {
  factory _$$CryptoError_KeyGenerationFailedImplCopyWith(
          _$CryptoError_KeyGenerationFailedImpl value, $Res Function(_$CryptoError_KeyGenerationFailedImpl) then) =
      __$$CryptoError_KeyGenerationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_KeyGenerationFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_KeyGenerationFailedImpl>
    implements _$$CryptoError_KeyGenerationFailedImplCopyWith<$Res> {
  __$$CryptoError_KeyGenerationFailedImplCopyWithImpl(
      _$CryptoError_KeyGenerationFailedImpl _value, $Res Function(_$CryptoError_KeyGenerationFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_KeyGenerationFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_KeyGenerationFailedImpl extends CryptoError_KeyGenerationFailed {
  const _$CryptoError_KeyGenerationFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.keyGenerationFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_KeyGenerationFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_KeyGenerationFailedImplCopyWith<_$CryptoError_KeyGenerationFailedImpl> get copyWith =>
      __$$CryptoError_KeyGenerationFailedImplCopyWithImpl<_$CryptoError_KeyGenerationFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return keyGenerationFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return keyGenerationFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (keyGenerationFailed != null) {
      return keyGenerationFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return keyGenerationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return keyGenerationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (keyGenerationFailed != null) {
      return keyGenerationFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_KeyGenerationFailed extends CryptoError {
  const factory CryptoError_KeyGenerationFailed({required final String message}) =
      _$CryptoError_KeyGenerationFailedImpl;
  const CryptoError_KeyGenerationFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_KeyGenerationFailedImplCopyWith<_$CryptoError_KeyGenerationFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_FileOperationFailedImplCopyWith<$Res> {
  factory _$$CryptoError_FileOperationFailedImplCopyWith(
          _$CryptoError_FileOperationFailedImpl value, $Res Function(_$CryptoError_FileOperationFailedImpl) then) =
      __$$CryptoError_FileOperationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_FileOperationFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_FileOperationFailedImpl>
    implements _$$CryptoError_FileOperationFailedImplCopyWith<$Res> {
  __$$CryptoError_FileOperationFailedImplCopyWithImpl(
      _$CryptoError_FileOperationFailedImpl _value, $Res Function(_$CryptoError_FileOperationFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_FileOperationFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_FileOperationFailedImpl extends CryptoError_FileOperationFailed {
  const _$CryptoError_FileOperationFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.fileOperationFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_FileOperationFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_FileOperationFailedImplCopyWith<_$CryptoError_FileOperationFailedImpl> get copyWith =>
      __$$CryptoError_FileOperationFailedImplCopyWithImpl<_$CryptoError_FileOperationFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return fileOperationFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return fileOperationFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (fileOperationFailed != null) {
      return fileOperationFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return fileOperationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return fileOperationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (fileOperationFailed != null) {
      return fileOperationFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_FileOperationFailed extends CryptoError {
  const factory CryptoError_FileOperationFailed({required final String message}) =
      _$CryptoError_FileOperationFailedImpl;
  const CryptoError_FileOperationFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_FileOperationFailedImplCopyWith<_$CryptoError_FileOperationFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_HashFailedImplCopyWith<$Res> {
  factory _$$CryptoError_HashFailedImplCopyWith(
          _$CryptoError_HashFailedImpl value, $Res Function(_$CryptoError_HashFailedImpl) then) =
      __$$CryptoError_HashFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_HashFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_HashFailedImpl>
    implements _$$CryptoError_HashFailedImplCopyWith<$Res> {
  __$$CryptoError_HashFailedImplCopyWithImpl(
      _$CryptoError_HashFailedImpl _value, $Res Function(_$CryptoError_HashFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_HashFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_HashFailedImpl extends CryptoError_HashFailed {
  const _$CryptoError_HashFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.hashFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_HashFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_HashFailedImplCopyWith<_$CryptoError_HashFailedImpl> get copyWith =>
      __$$CryptoError_HashFailedImplCopyWithImpl<_$CryptoError_HashFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return hashFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return hashFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (hashFailed != null) {
      return hashFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return hashFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return hashFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (hashFailed != null) {
      return hashFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_HashFailed extends CryptoError {
  const factory CryptoError_HashFailed({required final String message}) = _$CryptoError_HashFailedImpl;
  const CryptoError_HashFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_HashFailedImplCopyWith<_$CryptoError_HashFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_RsaOperationFailedImplCopyWith<$Res> {
  factory _$$CryptoError_RsaOperationFailedImplCopyWith(
          _$CryptoError_RsaOperationFailedImpl value, $Res Function(_$CryptoError_RsaOperationFailedImpl) then) =
      __$$CryptoError_RsaOperationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_RsaOperationFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_RsaOperationFailedImpl>
    implements _$$CryptoError_RsaOperationFailedImplCopyWith<$Res> {
  __$$CryptoError_RsaOperationFailedImplCopyWithImpl(
      _$CryptoError_RsaOperationFailedImpl _value, $Res Function(_$CryptoError_RsaOperationFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_RsaOperationFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_RsaOperationFailedImpl extends CryptoError_RsaOperationFailed {
  const _$CryptoError_RsaOperationFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.rsaOperationFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_RsaOperationFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_RsaOperationFailedImplCopyWith<_$CryptoError_RsaOperationFailedImpl> get copyWith =>
      __$$CryptoError_RsaOperationFailedImplCopyWithImpl<_$CryptoError_RsaOperationFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return rsaOperationFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return rsaOperationFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (rsaOperationFailed != null) {
      return rsaOperationFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return rsaOperationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return rsaOperationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (rsaOperationFailed != null) {
      return rsaOperationFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_RsaOperationFailed extends CryptoError {
  const factory CryptoError_RsaOperationFailed({required final String message}) = _$CryptoError_RsaOperationFailedImpl;
  const CryptoError_RsaOperationFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_RsaOperationFailedImplCopyWith<_$CryptoError_RsaOperationFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_SignatureVerificationFailedImplCopyWith<$Res> {
  factory _$$CryptoError_SignatureVerificationFailedImplCopyWith(_$CryptoError_SignatureVerificationFailedImpl value,
          $Res Function(_$CryptoError_SignatureVerificationFailedImpl) then) =
      __$$CryptoError_SignatureVerificationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CryptoError_SignatureVerificationFailedImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_SignatureVerificationFailedImpl>
    implements _$$CryptoError_SignatureVerificationFailedImplCopyWith<$Res> {
  __$$CryptoError_SignatureVerificationFailedImplCopyWithImpl(_$CryptoError_SignatureVerificationFailedImpl _value,
      $Res Function(_$CryptoError_SignatureVerificationFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CryptoError_SignatureVerificationFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_SignatureVerificationFailedImpl extends CryptoError_SignatureVerificationFailed {
  const _$CryptoError_SignatureVerificationFailedImpl({required this.message}) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'CryptoError.signatureVerificationFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_SignatureVerificationFailedImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_SignatureVerificationFailedImplCopyWith<_$CryptoError_SignatureVerificationFailedImpl> get copyWith =>
      __$$CryptoError_SignatureVerificationFailedImplCopyWithImpl<_$CryptoError_SignatureVerificationFailedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return signatureVerificationFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return signatureVerificationFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (signatureVerificationFailed != null) {
      return signatureVerificationFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return signatureVerificationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return signatureVerificationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (signatureVerificationFailed != null) {
      return signatureVerificationFailed(this);
    }
    return orElse();
  }
}

abstract class CryptoError_SignatureVerificationFailed extends CryptoError {
  const factory CryptoError_SignatureVerificationFailed({required final String message}) =
      _$CryptoError_SignatureVerificationFailedImpl;
  const CryptoError_SignatureVerificationFailed._() : super._();

  String get message;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_SignatureVerificationFailedImplCopyWith<_$CryptoError_SignatureVerificationFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoError_UnsupportedAlgorithmImplCopyWith<$Res> {
  factory _$$CryptoError_UnsupportedAlgorithmImplCopyWith(
          _$CryptoError_UnsupportedAlgorithmImpl value, $Res Function(_$CryptoError_UnsupportedAlgorithmImpl) then) =
      __$$CryptoError_UnsupportedAlgorithmImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String algorithm});
}

/// @nodoc
class __$$CryptoError_UnsupportedAlgorithmImplCopyWithImpl<$Res>
    extends _$CryptoErrorCopyWithImpl<$Res, _$CryptoError_UnsupportedAlgorithmImpl>
    implements _$$CryptoError_UnsupportedAlgorithmImplCopyWith<$Res> {
  __$$CryptoError_UnsupportedAlgorithmImplCopyWithImpl(
      _$CryptoError_UnsupportedAlgorithmImpl _value, $Res Function(_$CryptoError_UnsupportedAlgorithmImpl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? algorithm = null,
  }) {
    return _then(_$CryptoError_UnsupportedAlgorithmImpl(
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoError_UnsupportedAlgorithmImpl extends CryptoError_UnsupportedAlgorithm {
  const _$CryptoError_UnsupportedAlgorithmImpl({required this.algorithm}) : super._();

  @override
  final String algorithm;

  @override
  String toString() {
    return 'CryptoError.unsupportedAlgorithm(algorithm: $algorithm)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoError_UnsupportedAlgorithmImpl &&
            (identical(other.algorithm, algorithm) || other.algorithm == algorithm));
  }

  @override
  int get hashCode => Object.hash(runtimeType, algorithm);

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoError_UnsupportedAlgorithmImplCopyWith<_$CryptoError_UnsupportedAlgorithmImpl> get copyWith =>
      __$$CryptoError_UnsupportedAlgorithmImplCopyWithImpl<_$CryptoError_UnsupportedAlgorithmImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) invalidInput,
    required TResult Function(String message) encryptionFailed,
    required TResult Function(String message) decryptionFailed,
    required TResult Function(String message) keyGenerationFailed,
    required TResult Function(String message) fileOperationFailed,
    required TResult Function(String message) hashFailed,
    required TResult Function(String message) rsaOperationFailed,
    required TResult Function(String message) signatureVerificationFailed,
    required TResult Function(String algorithm) unsupportedAlgorithm,
  }) {
    return unsupportedAlgorithm(algorithm);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? invalidInput,
    TResult? Function(String message)? encryptionFailed,
    TResult? Function(String message)? decryptionFailed,
    TResult? Function(String message)? keyGenerationFailed,
    TResult? Function(String message)? fileOperationFailed,
    TResult? Function(String message)? hashFailed,
    TResult? Function(String message)? rsaOperationFailed,
    TResult? Function(String message)? signatureVerificationFailed,
    TResult? Function(String algorithm)? unsupportedAlgorithm,
  }) {
    return unsupportedAlgorithm?.call(algorithm);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? invalidInput,
    TResult Function(String message)? encryptionFailed,
    TResult Function(String message)? decryptionFailed,
    TResult Function(String message)? keyGenerationFailed,
    TResult Function(String message)? fileOperationFailed,
    TResult Function(String message)? hashFailed,
    TResult Function(String message)? rsaOperationFailed,
    TResult Function(String message)? signatureVerificationFailed,
    TResult Function(String algorithm)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (unsupportedAlgorithm != null) {
      return unsupportedAlgorithm(algorithm);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoError_InvalidInput value) invalidInput,
    required TResult Function(CryptoError_EncryptionFailed value) encryptionFailed,
    required TResult Function(CryptoError_DecryptionFailed value) decryptionFailed,
    required TResult Function(CryptoError_KeyGenerationFailed value) keyGenerationFailed,
    required TResult Function(CryptoError_FileOperationFailed value) fileOperationFailed,
    required TResult Function(CryptoError_HashFailed value) hashFailed,
    required TResult Function(CryptoError_RsaOperationFailed value) rsaOperationFailed,
    required TResult Function(CryptoError_SignatureVerificationFailed value) signatureVerificationFailed,
    required TResult Function(CryptoError_UnsupportedAlgorithm value) unsupportedAlgorithm,
  }) {
    return unsupportedAlgorithm(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoError_InvalidInput value)? invalidInput,
    TResult? Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult? Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult? Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult? Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult? Function(CryptoError_HashFailed value)? hashFailed,
    TResult? Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult? Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult? Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
  }) {
    return unsupportedAlgorithm?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoError_InvalidInput value)? invalidInput,
    TResult Function(CryptoError_EncryptionFailed value)? encryptionFailed,
    TResult Function(CryptoError_DecryptionFailed value)? decryptionFailed,
    TResult Function(CryptoError_KeyGenerationFailed value)? keyGenerationFailed,
    TResult Function(CryptoError_FileOperationFailed value)? fileOperationFailed,
    TResult Function(CryptoError_HashFailed value)? hashFailed,
    TResult Function(CryptoError_RsaOperationFailed value)? rsaOperationFailed,
    TResult Function(CryptoError_SignatureVerificationFailed value)? signatureVerificationFailed,
    TResult Function(CryptoError_UnsupportedAlgorithm value)? unsupportedAlgorithm,
    required TResult orElse(),
  }) {
    if (unsupportedAlgorithm != null) {
      return unsupportedAlgorithm(this);
    }
    return orElse();
  }
}

abstract class CryptoError_UnsupportedAlgorithm extends CryptoError {
  const factory CryptoError_UnsupportedAlgorithm({required final String algorithm}) =
      _$CryptoError_UnsupportedAlgorithmImpl;
  const CryptoError_UnsupportedAlgorithm._() : super._();

  String get algorithm;

  /// Create a copy of CryptoError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoError_UnsupportedAlgorithmImplCopyWith<_$CryptoError_UnsupportedAlgorithmImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
